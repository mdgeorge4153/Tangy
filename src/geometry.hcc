#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include <iostream>
#include "algebra.h"


namespace CGAL {
	template<>
	class Algebraic_structure_traits<ExtendedRational>
		: public Algebraic_structure_traits_base<ExtendedRational, Field_tag>
	{
	};

	template<>
	class Real_embeddable_traits<ExtendedRational>
		: public INTERN_RET::Real_embeddable_traits_base<ExtendedRational, Tag_true>
	{
	};
}

template<typename polygon>
void
print_map(const polygon & poly)
{
	typedef typename polygon::Explorer                 explorer;
	typedef typename explorer::Vertex_const_iterator   vert_iter;
	typedef typename explorer::Halfedge_const_iterator edge_iter;

	explorer E = poly.explorer();

	for (vert_iter i = E.vertices_begin(); i != E.vertices_end(); i++)
		if (E.is_standard(i))
			std::cout << "\\draw[result] (" << float(E.point(i).x()) << ", " << float(E.point(i).y()) << ") circle (2pt);" << std::endl;

	for (edge_iter i = E.halfedges_begin(); i != E.halfedges_end(); i++)
		if (E.is_standard(E.source(i)) && E.is_standard(E.target(i)))
			std::cout << "\\draw[result] (" << float(E.point(E.source(i)).x()) << ", " << float(E.point(E.source(i)).y()) << ") -- ("
			                                << float(E.point(E.target(i)).x()) << ", " << float(E.point(E.target(i)).y()) << ");" << std::endl;
}

template<typename GameTraits>
ObstacleSet<GameTraits>::
ObstacleSet (const_tan_handle moving, const tanset & fixed)
	: _impl(polygon::EMPTY)
{
	for (const_tan_handle i = fixed.begin(); i != fixed.end(); i++)
		if (i != moving)
			add_sum(moving, i);

	std::cout << "\\begin{tikzpicture}" << std::endl;
	std::cout << "\\draw (-1, 0) -- (10, 0) (-1, 0) -- (6,0);" << std::endl;

	for (const_tan_handle i = fixed.begin(); i != fixed.end(); i++)
	{
		std::vector<point> ps;
		i->points(std::back_inserter(ps));

		std::cout << "\\draw"
		          << (i == moving ? "[moving] " : "[fixed]  ")
		          << approximate(i->pos())
		          << " circle (2pt) " << std::endl;
		for (typename std::vector<point>::iterator j = ps.begin (); j != ps.end(); j++)
			std::cout << approximate(*j) << " -- " << std::endl << "              ";
		std::cout << "cycle;" << std::endl;
	}

	print_map(_impl);

	std::cout << "\\end{tikzpicture}" << std::endl;
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::point
ObstacleSet<GameTraits>::
closest (const point & p) const
{
	return p;
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::cgal_point
ObstacleSet<GameTraits>::
convert (const point & p)
{
	return cgal_point(p.real(), p.imag());
}

template<typename GameTraits>
bool
ObstacleSet<GameTraits>::
less_rot (const point & a, const point & b)
{
	if (a.imag() > number(0) && b.imag() < number(0))
		// angle(a) < 180 < angle(b)
		return true;
	else if (a.imag() < number(0) && b.imag() > number(0))
		// angle(b) < 180 < angle(a)
		return false;
	else
		// a and b are in same half-plane so
		// -180 < angle(a) - angle(b) < 180
		return (a * std::conj(b)).imag() < number(0);
}

template<typename GameTraits>
bool
ObstacleSet<GameTraits>::
south_of (const point & a, const point & b)
{
	return a.imag() < b.imag();
}

template<typename GameTraits>
void
ObstacleSet<GameTraits>::
add_sum (const_tan_handle moving, const_tan_handle fixed)
{
	typedef std::vector<point>           container;
	typedef typename container::iterator iterator;

	// let fps and mps be the points of fixed and moving respectively
	container fps, mps;
	fixed ->points(std::back_inserter(fps));
	moving->points(std::back_inserter(mps));

	// print
	std::cout << "\\begin{tikzpicture}" << std::endl;
	std::cout << "\\draw[dotted] (-5, 0) -- (5, 0) (0, -5) -- (0, 5);" << std::endl;

	std::cout << "\\draw[moving]    " << approximate(moving->pos()) << " circle (2pt);" << std::endl;
	std::cout << "\\draw[moving,->] ";
	for (iterator i = mps.begin(); i != mps.end(); i++)
		std::cout << approximate(*i) << " node {" << i - mps.begin() << "} -- ";
	std::cout << "cycle;" << std::endl << std::endl;

	std::cout << "\\draw[fixed]     " << approximate(fixed->pos()) << " circle (2pt);" << std::endl;
	std::cout << "\\draw[fixed,->]  ";
	for (iterator i = fps.begin(); i != fps.end(); i++)
		std::cout << approximate(*i) << " node {" << i - fps.begin() << "} -- " << std::endl;
	std::cout << "cycle;" << std::endl << std::endl;

	// flip moving tan
	std::transform(mps.begin(), mps.end(), mps.begin(), std::negate<point> ());

	// find southmost vertices
	iterator fmin = std::min_element(fps.begin(), fps.end(), south_of);
	iterator mmin = std::min_element(mps.begin(), mps.end(), south_of);

	point fsouth = * fmin;
	point msouth = * mmin;

	// reorder both so that the southmost vertex is last
	std::rotate(fps.begin(), ++fmin, fps.end());
	std::rotate(mps.begin(), ++mmin, mps.end());

	// convert to lists of vectors
	std::adjacent_difference (fps.begin(), fps.end(), fps.begin());
	std::adjacent_difference (mps.begin(), mps.end(), mps.begin());

	fps[0] -= fsouth;
	mps[0] -= msouth;

	// merge sort vectors
	container result;
	std::merge(fps.begin(), fps.end(), mps.begin(), mps.end(), std::back_inserter(result), less_rot);

	// turn back into points
	result[0] += fsouth + msouth + moving->pos();
	std::partial_sum (result.begin(), result.end(), result.begin());

	// print
	std::cout << "\\draw[result] ";
	for (iterator i = result.begin(); i != result.end(); i++)
		std::cout << approximate(*i) << " node {" << i - result.begin() << "}" << " -- ";
	std::cout << "cycle;" << std::endl << std::endl;
	std::cout << "\\end{tikzpicture}" << std::endl << std::endl;

	// convert to CGAL points
	std::vector<cgal_point> rps;
	std::transform (result.begin(), result.end(), std::back_inserter(rps), convert);

	// union in results
	polygon bdry (rps.begin(), rps.end(), polygon::EXCLUDED);

	_impl += bdry;
}

/*
** vim: ts=4 sw=4 cindent syntax=cpp
*/
