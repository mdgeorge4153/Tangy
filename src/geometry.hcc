#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include "algebra.h"

namespace CGAL {
	template<>
	class Algebraic_structure_traits<ExtendedRational>
		: public Algebraic_structure_traits_base<ExtendedRational, Field_tag>
	{
	};

	template<>
	class Real_embeddable_traits<ExtendedRational>
		: public INTERN_RET::Real_embeddable_traits_base<ExtendedRational, Tag_true>
	{
	};
}

template<typename GameTraits>
struct ObstacleSet<GameTraits>::closest_to
{
	typedef typename ObstacleSet<GameTraits>::cgal_point cgal_point;
	const cgal_point & _p;

	closest_to (const cgal_point & p)
		: _p(p)
	{
	}

	bool operator() (const cgal_point & a, const cgal_point & b)
	{
		return CGAL::compare_distance_to_point (_p, a, b) == CGAL::SMALLER;
	}
};


template<typename GameTraits>
ObstacleSet<GameTraits>::
ObstacleSet (const_tan_handle moving, const tanset & fixed)
	: _impl(polygon::COMPLETE)
{
	for (const_tan_handle i = fixed.begin(); i != fixed.end(); i++)
		if (i != moving)
			add_sum(moving, i);
}

template<typename GameTraits>
ObstacleSet<GameTraits>::
ObstacleSet ()
	: _impl(polygon::COMPLETE)
{
}

template<typename GameTraits>
ObstacleSet<GameTraits> &
ObstacleSet<GameTraits>::
operator= (const ObstacleSet<GameTraits> & other)
{
	_impl = other._impl;
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::point
ObstacleSet<GameTraits>::
closest (const point & _p) const
{
	typedef typename polygon::Object_handle                   object;
	typedef typename explorer::Face_const_handle              face;
	typedef typename explorer::Isolated_vertex_const_iterator vertex;
	typedef typename explorer::Halfedge_const_iterator        edge;
	typedef typename explorer::Hole_const_iterator            hole;
	typedef typename explorer::Halfedge_around_face_const_circulator face_edge;

	cgal_point p = convert(_p);
	explorer   e = mask();

	object o = _impl.locate(p);
	if (_impl.contains(o))
		return _p;

	// by construction, all standard vertices and edges are contained in _impl
	// so o must be a face
	face f;
	assert (CGAL::assign(f, o));

	//
	// iterate over features adjacent to f to find the closest point on each feature
	//
	std::vector<cgal_point> candidates;

	// isolated vertices
	for (vertex i = e.isolated_vertices_begin(f); i != e.isolated_vertices_end(f); i++)
		candidates.push_back(e.point(i));

	// holes
	for (hole i = e.holes_begin(f); i != e.holes_end(f); i++)
	{
		edge j = i;
		do
		{
			candidates.push_back(closest(p, e.point(e.source(j)), e.point(e.target(j))));
		} while (++j != i);
	}

	// outer edge
	face_edge i = e.face_cycle (f);
	if (i != 0 && !e.is_frame_edge(i))
		do
		{
			candidates.push_back(closest(p, e.point(e.source(i)), e.point(e.target(i))));
		} while (++i != e.face_cycle(f));

	//
	// select and return the best candidate
	//
	typename std::vector<cgal_point>::iterator best = std::min_element(candidates.begin(), candidates.end(), closest_to(p));

	return point(best->x(), best->y());
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::explorer
ObstacleSet<GameTraits>::
mask () const
{
	return _impl.explorer();
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::cgal_point
ObstacleSet<GameTraits>::
closest (const cgal_point & p, const cgal_point & source, const cgal_point & target)
{
	number dot = (p - source) * (target - source);

	if (dot < number(0))
		return source;

	else if (dot > (target - source) * (target - source))
		return target;

	else
		return source + dot * (target - source) / ((target - source) * (target - source));
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::cgal_point
ObstacleSet<GameTraits>::
convert (const point & p)
{
	return cgal_point(p.real(), p.imag());
}

template<typename GameTraits>
bool
ObstacleSet<GameTraits>::
less_rot (const point & a, const point & b)
{
	if (a.imag() > number(0) && b.imag() < number(0))
		// angle(a) < 180 < angle(b)
		return true;
	else if (a.imag() < number(0) && b.imag() > number(0))
		// angle(b) < 180 < angle(a)
		return false;
	else
		// a and b are in same half-plane so
		// -180 < angle(a) - angle(b) < 180
		return (a * std::conj(b)).imag() < number(0);
}

template<typename GameTraits>
bool
ObstacleSet<GameTraits>::
south_of (const point & a, const point & b)
{
	return a.imag() < b.imag();
}

template<typename GameTraits>
void
ObstacleSet<GameTraits>::
add_sum (const_tan_handle moving, const_tan_handle fixed)
{
	typedef std::vector<point>           container;
	typedef typename container::iterator iterator;

	// let fps and mps be the points of fixed and moving respectively
	container fps, mps;
	fixed ->points(std::back_inserter(fps));
	moving->points(std::back_inserter(mps));

	// flip moving tan
	std::transform(mps.begin(), mps.end(), mps.begin(), std::negate<point> ());

	// find southmost vertices
	iterator fmin = std::min_element(fps.begin(), fps.end(), south_of);
	iterator mmin = std::min_element(mps.begin(), mps.end(), south_of);

	point fsouth = * fmin;
	point msouth = * mmin;

	// reorder both so that the southmost vertex is last
	std::rotate(fps.begin(), ++fmin, fps.end());
	std::rotate(mps.begin(), ++mmin, mps.end());

	// convert to lists of vectors
	std::adjacent_difference (fps.begin(), fps.end(), fps.begin());
	std::adjacent_difference (mps.begin(), mps.end(), mps.begin());

	fps[0] -= fsouth;
	mps[0] -= msouth;

	// merge sort vectors
	container result;
	std::merge(fps.begin(), fps.end(), mps.begin(), mps.end(), std::back_inserter(result), less_rot);

	// turn back into points
	result[0] += fsouth + msouth + moving->pos();
	std::partial_sum (result.begin(), result.end(), result.begin());

	// convert to CGAL points
	std::vector<cgal_point> rps;
	std::transform (result.begin(), result.end(), std::back_inserter(rps), convert);

	// union in results
	_impl -= polygon (rps.begin(), rps.end(), polygon::EXCLUDED);

}

/*
** vim: ts=4 sw=4 cindent syntax=cpp
*/
