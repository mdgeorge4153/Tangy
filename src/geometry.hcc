#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include "algebra.h"
#include "utils.h"
#include <CGAL/Kernel_traits.h>

/*
** Helper function declarations ************************************************
*/

template<typename in, typename out> out convert_from_cgal_point (const in &);
template<typename in, typename out> out convert_from_complex    (const in &);

template<typename cgal_point> struct closest_to_t;
template<typename cgal_point> closest_to_t<cgal_point> closest_to (const cgal_point &);
template<typename cgal_point> cgal_point               closest_point_on_segment (const cgal_point &, const cgal_point &, const cgal_point &);

template<typename point>      bool south_of (const point  & a, const point  & b);
template<typename vector>     bool less_rot (const vector & a, const vector & b);

template<typename TanA, typename TanB, typename Out> Out sum (TanA, TanB, Out);



/*
** ObstacleSet Implementation **************************************************
*/

template<typename GameTraits>
ObstacleSet<GameTraits>::
ObstacleSet (const tan * moving, const tanset & fixed)
	: _impl(polygon::COMPLETE)
{
	typename std::vector<typename std::vector<cgal_point> > polygons;
	for (const_tan_handle i = fixed.begin(); i != fixed.end(); i++)
		if (&(* i) != moving)
		{
			std::vector<point> points;
			sum(moving, i, std::back_inserter(points));

			std::vector<cgal_point> cgal_points;
			std::transform (points.begin(), points.end(),
			                std::back_inserter(cgal_points),
			                convert_from_complex<point, cgal_point>);
			_impl -= polygon(cgal_points.begin(), cgal_points.end(), polygon::EXCLUDED);
		}
}

template<typename GameTraits>
ObstacleSet<GameTraits>::
ObstacleSet ()
	: _impl(polygon::COMPLETE)
{
}

template<typename GameTraits>
ObstacleSet<GameTraits> &
ObstacleSet<GameTraits>::
operator= (const ObstacleSet<GameTraits> & other)
{
	_impl = other._impl;
	return (*this);
}

template<typename GameTraits>
typename ObstacleSet<GameTraits>::point
ObstacleSet<GameTraits>::
closest (const point & _p) const
{
	typedef typename polygon::Object_handle                   object;
	typedef typename explorer::Face_const_handle              face;
	typedef typename explorer::Isolated_vertex_const_iterator vertex;
	typedef typename explorer::Halfedge_const_iterator        edge;
	typedef typename explorer::Hole_const_iterator            hole;
	typedef typename explorer::Halfedge_around_face_const_circulator face_edge;

	cgal_point p = convert_from_complex<point, cgal_point>(_p);
	explorer   e = _impl.explorer();

	object o = _impl.locate(p);
	if (_impl.contains(o))
		return _p;

	// by construction, all standard vertices and edges are contained in _impl
	// so o must be a face
	face f;
	assert (CGAL::assign(f, o));

	//
	// iterate over features adjacent to f to find the closest point on each feature
	//
	std::vector<cgal_point> candidates;

	// isolated vertices
	for (vertex i = e.isolated_vertices_begin(f); i != e.isolated_vertices_end(f); i++)
		candidates.push_back(e.point(i));

	// holes
	for (hole i = e.holes_begin(f); i != e.holes_end(f); i++)
	{
		edge j = i;
		do
		{
			candidates.push_back(closest_point_on_segment(p, e.point(e.source(j)), e.point(e.target(j))));
		} while (++j != i);
	}

	// outer edge
	face_edge i = e.face_cycle (f);
	if (i != 0 && !e.is_frame_edge(i))
		do
		{
			candidates.push_back(closest_point_on_segment(p, e.point(e.source(i)), e.point(e.target(i))));
		} while (++i != e.face_cycle(f));

	//
	// select and return the best candidate
	//
	typename std::vector<cgal_point>::iterator best = std::min_element(candidates.begin(), candidates.end(), closest_to(p));

	return point(best->x(), best->y());
}

/*
** CGAL type traits for ExtendedRationals **************************************
*/

namespace CGAL {
	template<>
	class Algebraic_structure_traits<ExtendedRational>
		: public Algebraic_structure_traits_base<ExtendedRational, Field_tag>
	{
	};

	template<>
	class Real_embeddable_traits<ExtendedRational>
		: public INTERN_RET::Real_embeddable_traits_base<ExtendedRational, Tag_true>
	{
	};
}

/*
** Nef policy implementation ***************************************************
*/

/*
** Arrangement policy implementation *******************************************
*/

/*
template<typename GameTraits>
struct ObstacleSet<GameTraits>::union_traits
{
	typedef typename arrangement::Vertex_handle   Vertex_handle_A,   Vertex_handle_B,   Vertex_handle_R;
	typedef typename arrangement::Halfedge_handle Halfedge_handle_A, Halfedge_handle_B, Halfedge_handle_R;
	typedef typename arrangement::Face_handle     Face_handle_A,     Face_handle_B,     Face_handle_R;

	inline void create_vertex (Vertex_handle_A   a, Vertex_handle_B   b, Vertex_handle_R r) {r.set_data(false);}
	inline void create_vertex (Vertex_handle_A   a, Halfedge_handle_B b, Vertex_handle_R r) {r.set_data(false);}
	inline void create_vertex (Vertex_handle_A   a, Face_handle_B     b, Vertex_handle_R r) {r.set_data(b.data());}
	inline void create_vertex (Halfedge_handle_A a, Vertex_handle_B   b, Vertex_handle_R r) {r.set_data(false);}
	inline void create_vertex (Halfedge_handle_A a, Halfedge_handle_B b, Vertex_handle_R r) {r.set_data(false);}
	inline void create_vertex (Face_handle_A     a, Halfedge_handle_B b, Vertex_handle_R r) {r.set_data(a.data());}

	inline void create_edge (Halfedge_handle_A a, Halfedge_handle_B b, Halfedge_handle_R r) {r.set_data(false);}
	inline void create_edge (Halfedge_handle_A a, Face_handle_B     b, Halfedge_handle_R r) {r.set_data(b.data());}
	inline void create_edge (Face_handle_A     a, Halfedge_handle_B b, Halfedge_handle_R r) {r.set_data(a.data());}

	inline void create_face (Face_handle_A a, Face_handle_B b, Face_handle_R r)             {r.set_data(a.data() || b.data());}
};

template<typename GameTraits>
template<typename InputIterator>
void
ObstacleSet<GameTraits>::
join (InputIterator begin, InputIterator end, arrangement & out)
{
	assert (begin != end);

	if (begin - end == 1)
		out = *begin;

	else
	{
		arrangement left, right;
		InputIterator mid = begin + (end - begin) / 2;
		join (begin, mid, left);
		join (mid, end, right);

		union_traits ut;
		CGAL::overlay (left, right, out, ut);
	}
}
*/

/*
** Helper functions ************************************************************
*/

/*
 * closest_to(p) returns a comparator that ranks points by
 * their distance from p
 */
template<typename cgal_point>
struct closest_to_t
{
	const cgal_point & _p;

	closest_to_t (const cgal_point & p)
		: _p(p)
	{
	}

	bool operator() (const cgal_point & a, const cgal_point & b)
	{
		return CGAL::compare_distance_to_point (_p, a, b) == CGAL::SMALLER;
	}
};

template<typename cgal_point>
closest_to_t<cgal_point>
closest_to (const cgal_point & p)
{
	return closest_to_t<cgal_point> (p);
}

/* turns std::complex style points into other representations */
template<typename in, typename out>
out
convert_from_complex (const in & p)
{
	return out(p.real(), p.imag());
}

/* turns CGAL::Point_2 style points into other representations.  */
template<typename in, typename out>
out
convert_from_cgal_point (const in & p)
{
	return out(p.x(), p.y());
}

/*
 * less_rot is a comparator that ranks vectors by the angle
 * they form with the x-axis
 */
template<typename vector>
bool
less_rot (const vector & a, const vector & b)
{
	typedef typename vector::value_type number;

	if (a.imag() > number(0) && b.imag() < number(0))
		// angle(a) < 180 < angle(b)
		return true;
	else if (a.imag() < number(0) && b.imag() > number(0))
		// angle(b) < 180 < angle(a)
		return false;
	else
		// a and b are in same half-plane so
		// -180 < angle(a) - angle(b) < 180
		return (a * std::conj(b)).imag() < number(0);
}

/*
 * south_of is a copmarator that ranks points by their y
 * component.
 */
template<typename point>
bool
south_of (const point & a, const point & b)
{
	return a.imag() < b.imag();
}

/*
 * sum outputs the minkowski sum of two tans into an
 * output_iterator<point>.
 */
template<typename TanA, typename TanB, typename Out>
Out
sum (TanA moving, TanB fixed, Out out)
{
	typedef typename std::iterator_traits<TanA>::value_type tan;
	typedef typename tan::point          point;
	typedef typename std::vector<point>  container;
	typedef typename container::iterator iterator;

	// let fps and mps be the points of fixed and moving respectively
	container fps, mps;
	fixed ->points(std::back_inserter(fps));
	moving->points(std::back_inserter(mps));

	// flip moving tan
	std::transform(mps.begin(), mps.end(), mps.begin(), std::negate<point> ());

	// find southmost vertices
	iterator fmin = std::min_element(fps.begin(), fps.end(), south_of<point>);
	iterator mmin = std::min_element(mps.begin(), mps.end(), south_of<point>);

	// reorder both so that the southmost vertex is last
	std::rotate(fps.begin(), ++fmin, fps.end());
	std::rotate(mps.begin(), ++mmin, mps.end());

	// convert to lists of vectors
	point fsouth = circular_difference (fps.begin(), fps.end(), fps.begin());
	point msouth = circular_difference (mps.begin(), mps.end(), mps.begin());

	// merge sort vectors by the angle they form with the x-axis
	container result;
	std::merge(fps.begin(), fps.end(), mps.begin(), mps.end(), std::back_inserter(result), less_rot<point>);

	// turn the vectors back into points
	return circular_sum (result.begin(), result.end(), out, fsouth + msouth + moving->pos());
}

template<typename cgal_point>
cgal_point
closest_point_on_segment (const cgal_point & p, const cgal_point & source, const cgal_point & target)
{
	typedef typename CGAL::Kernel_traits<cgal_point>::Kernel::RT number;

	number dot = (p - source) * (target - source);

	if (dot < number(0))
		return source;

	else if (dot > (target - source) * (target - source))
		return target;

	else
		return source + dot * (target - source) / ((target - source) * (target - source));
}


/*
** vim: ts=4 sw=4 cindent syntax=cpp
*/
