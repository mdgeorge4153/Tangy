#include<iterator>
#include<algorithm>
#include<functional>

/*
** Tans ************************************************************************
*/

template<typename GT>
void
Tan<GT>::
flip ()
{
	this->_conj = !this->_conj;
	this->_points_valid = false;
}

template<typename GT>
void
Tan<GT>::
set_pos (const point & pos)
{
	this->_pos = this->_desired_pos = pos;
	this->_points_valid = false;
}

template<typename GT>
void
Tan<GT>::
set_rot (const vector & rot)
{
	this->_desired_rot = rot;
	this->_rot = normalize(rot);
	this->_points_valid = false;
}

template<typename GT>
void
Tan<GT>::
pacify ()
{
	this->_desired_pos = this->_pos;
	this->_desired_rot = this->_rot;
}

template<typename GT>
const typename Tan<GT>::vector_container &
Tan<GT>::
shape () const
{
	return _shape;
}

template<typename GT>
const typename Tan<GT>::point &
Tan<GT>::
pos () const
{
	return _pos;
}

template<typename GT>
const typename Tan<GT>::vector &
Tan<GT>::
rot () const
{
	return _rot;
}

template<typename GT>
const bool
Tan<GT>::
conj () const
{
	return _conj;
}

template<typename GT>
template<typename OutputIterator>
OutputIterator
Tan<GT>::
points (OutputIterator out) const
{
	if (!_points_valid)
	{
		_points.clear();
		for (unsigned i = 0; i < _shape.size(); i++)
		{
			vector offset = _shape[i];
			offset *= _rot;
			if (_conj)
				offset = std::conj(offset);
			_points.push_back (_pos + offset);
		}

		_points_valid = true;
	}

	return std::copy(_points.begin(), _points.end(), out);
}

template<typename GT>
bool
Tan<GT>::
is_offset () const
{
	return _pos != _desired_pos;
}

template<typename GT>
const typename Tan<GT>::point &
Tan<GT>::
desired_pos () const
{
	return _desired_pos;
}

template<typename GT>
const typename Tan<GT>::vector &
Tan<GT>::
desired_rot () const
{
	return _desired_rot;
}

template<typename GT>
bool
Tan<GT>::
contains (const point & p) const
{
	typedef typename std::vector<vector> pointset;

	vector offset = p - this->_pos;
	if (this->_conj)
		offset = std::conj(offset);
	offset *= std::conj(this->_rot);

	int l = _shape.size() - 1;
	for (unsigned i = 0; i < _shape.size(); i++)
	{
		vector ltop = offset    - _shape[l];
		vector ltoi = _shape[i] - _shape[l];

		vector angle = std::conj(ltop) * ltoi;

		if (angle.imag() > typename GT::number(0))
			return false;

		l = i;
	}

	return true;
}

template<typename GT>
Tan<GT>::
Tan ()
	: _pos(0,0),
	  _desired_pos(0,0),
	  _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape(),
	  _points(),
	  _points_valid(false)
{
}

template<typename GT>
Tan<GT>::
Tan (point p0, point p1, point p2)
	: _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape(3),
	  _points(),
	  _points_valid(false)
{
	_shape[0] = p0;
	_shape[1] = p1;
	_shape[2] = p2;

	_pos = _shape.sum() / point(3);
	_shape -= _pos;
	_desired_pos = _pos;
}

template<typename GT>
Tan<GT>::
Tan(point p0, point p1, point p2, point p3)
	: _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape(4),
	  _points(),
	  _points_valid(false)
{
	_shape[0] = p0;
	_shape[1] = p1;
	_shape[2] = p2;
	_shape[3] = p3;

	_pos = _shape.sum() / point(4);
	_shape -= _pos;
	_desired_pos = _pos;
}

template<typename GT>
template<typename GT2>
Tan<GT>::
Tan (const Tan<GT2> & other)
	: _pos(other._pos),
	  _desired_pos(other._desired_pos),
	  _rot(other._rot),
	  _desired_rot(other._desired_rot),
	  _conj(other._conj),
	  _shape(other._shape),
	  _points(),
	  _points_valid(false)
{
}

/*
** Tan Set *********************************************************************
*/

template<typename GT>
TanSet<GT>::
TanSet ()
	: _tans()
{
	typedef typename GT::point  point;
	typedef typename GT::number number;

	// shapes
	_tans.push_back(tan(point(0,2), point(0,0), point(2,0)));             // big triangle
	_tans.push_back(tan(point(0,2), point(2,0), point(2,2)));             // big triangle
	_tans.push_back(tan(point(0,2), point(0,0), point(1,1)));             // medium triangle
	_tans.push_back(tan(point(1,1), point(0,1), point(1,0)));             // small triangle
	_tans.push_back(tan(point(0,0), point(1,0), point(2,1), point(1,1))); // parallelogram
	_tans.push_back(tan(point(1,1), point(0,0), point(1,0)));             // small triangle
	_tans.push_back(tan(point(0,1), point(0,0), point(1,0), point(1,1))); // square

	// positions
	_tans[0]._pos += point(1,1)  / number(2);
	_tans[1]._pos += point(1,2)  / number(2);
	_tans[2]._pos += point(11,3) / number(4);
	_tans[3]._pos += point(3,2)  / number(1);
	_tans[4]._pos += point(13,3) / number(4);
	_tans[5]._pos += point(9,1)  / number(2);
	_tans[6]._pos += point(17,8) / number(4);
}

template<typename GT>
template<typename TS>
TanSet<GT>::
TanSet (const TS & other)
	: _tans(other.tans()), _selection(other._selection)
{
}

template<typename GT>
void
TanSet<GT>::
set_size (int w, int h)
{
	// TODO
}

template<typename GT>
template<typename PointIter>
void
TanSet<GT>::
add_obstacle (PointIter begin, PointIter end)
{
	// TODO
}

template<typename GT>
void
TanSet<GT>::
pan (const vector & off)
{
	for (typename container::iterator i = _tans.begin(); i != _tans.end(); i++)
	{
		i->_pos += off;
		i->_points_valid = false;
	}
}

template<typename GT>
const typename TanSet<GT>::container &
TanSet<GT>::
tans () const
{
	return _tans;
}

template<typename GT>
const typename TanSet<GT>::tan &
TanSet<GT>::
selection () const
{
	// TODO
}

template<typename GT>
typename TanSet<GT>::const_tan_handle
TanSet<GT>::
find (const point & p) const
{
	for (typename container::iterator i = _tans.begin(); i != _tans.end(); i++)
		if (i->contains(p))
			return i;

	return NULL;
}

template<typename GT>
typename TanSet<GT>::tan_handle
TanSet<GT>::
find (const point & p)
{
	return std::find_if (begin(), end(), bind2nd(mem_fun_ref(&tan::contains), p));
}

template<typename GT>
typename TanSet<GT>::const_tan_handle
TanSet<GT>::
begin () const
{
	return _tans.begin();
}

template<typename GT>
typename TanSet<GT>::tan_handle
TanSet<GT>::
begin ()
{
	return _tans.begin();
}

template<typename GT>
typename TanSet<GT>::const_tan_handle
TanSet<GT>::
end () const
{
	return _tans.end();
}

template<typename GT>
typename TanSet<GT>::tan_handle
TanSet<GT>::
end ()
{
	return _tans.end ();
}

/*
** vim: syntax=cpp ts=4 sw=4 cindent
*/
