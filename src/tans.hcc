

/*
** Tans ************************************************************************
*/

template<typename GT>
void
Tan<GT>::
flip ()
{
	this->_conj = !this->_conj;
}

template<typename GT>
void
Tan<GT>::
set_pos (const point & pos)
{
	this->_pos = this->_desired_pos = pos;
}

template<typename GT>
void
Tan<GT>::
set_rot (const vector & rot)
{
	this->_rot = this->_desired_rot = rot;
}

template<typename GT>
void
Tan<GT>::
pacify ()
{
	this->_desired_pos = this->_pos;
	this->_desired_rot = this->_rot;
}

template<typename GT>
const typename Tan<GT>::vector_container &
Tan<GT>::
shape () const
{
	return _shape;
}

template<typename GT>
const typename Tan<GT>::point &
Tan<GT>::
pos () const
{
	return _pos;
}

template<typename GT>
const typename Tan<GT>::vector &
Tan<GT>::
rot () const
{
	return _rot;
}

template<typename GT>
const bool
Tan<GT>::
conj () const
{
	return _conj;
}

template<typename GT>
template<typename OutputIterator>
OutputIterator
Tan<GT>::
points (OutputIterator out) const
{
	for (unsigned i = 0; i < _shape.size(); i++)
	{
		vector offset = _shape[i];
		if (_conj)
			offset = std::conj(offset);
		offset *= _rot;
		(* out++) = _pos + offset;
	}

	return out;
}

template<typename GT>
bool
Tan<GT>::
is_offset () const
{
	return _pos != _desired_pos;
}

template<typename GT>
const typename Tan<GT>::point &
Tan<GT>::
desired_pos () const
{
	return _desired_pos;
}

template<typename GT>
const typename Tan<GT>::vector &
Tan<GT>::
desired_rot () const
{
	return _desired_rot;
}

template<typename GT>
bool
Tan<GT>::
contains (const point &) const
{
	// TODO
	return true;
}

template<typename GT>
Tan<GT>::
Tan ()
	: _pos(0,0),
	  _desired_pos(0,0),
	  _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape()
{
}

template<typename GT>
Tan<GT>::
Tan (point p0, point p1, point p2)
	: _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape(3)
{
	_shape[0] = p0;
	_shape[1] = p1;
	_shape[2] = p2;

	_pos = _shape.sum() / point(3);
	_shape -= _pos;
	_desired_pos = _pos;
}

template<typename GT>
Tan<GT>::
Tan(point p0, point p1, point p2, point p3)
	: _rot(1),
	  _desired_rot(1),
	  _conj(false),
	  _shape(4)
{
	_shape[0] = p0;
	_shape[1] = p1;
	_shape[2] = p2;
	_shape[3] = p3;

	_pos = _shape.sum() / point(4);
	_shape -= _pos;
	_desired_pos = _pos;
}

template<typename GT>
template<typename GT2>
Tan<GT>::
Tan (const Tan<GT2> & other)
	: _pos(other._pos),
	  _desired_pos(other._desired_pos),
	  _rot(other._rot),
	  _desired_rot(other._desired_rot),
	  _conj(other._conj),
	  _shape(other._shape)
{
}

/*
** Tan Set *********************************************************************
*/

template<typename GT>
TanSet<GT>::
TanSet ()
	: _tans()
{
	typedef typename GT::point  point;
	typedef typename GT::number number;

	// shapes
	_tans.push_back(tan(point(0,0), point(0,2), point(2,0)));             // big triangle
	_tans.push_back(tan(point(2,0), point(2,2), point(0,2)));             // big triangle
	_tans.push_back(tan(point(0,0), point(0,2), point(1,1)));             // medium triangle
	_tans.push_back(tan(point(0,1), point(1,1), point(1,0)));             // small triangle
	_tans.push_back(tan(point(0,0), point(1,1), point(2,1), point(1,0))); // parallelogram
	_tans.push_back(tan(point(0,0), point(1,1), point(1,0)));             // small triangle
	_tans.push_back(tan(point(0,0), point(0,1), point(1,1), point(1,0))); // square

	// positions
	_tans[0]._pos += point(1,1)  / number(2);
	_tans[1]._pos += point(1,2)  / number(2);
	_tans[2]._pos += point(11,3) / number(4);
	_tans[3]._pos += point(3,2)  / number(1);
	_tans[4]._pos += point(13,3) / number(4);
	_tans[5]._pos += point(9,1)  / number(2);
	_tans[6]._pos += point(17,8) / number(4);
}

template<typename GT>
template<typename TS>
TanSet<GT>::
TanSet (const TS & other)
	: _tans(other.tans()), _selection(other._selection)
{
}

template<typename GT>
void
TanSet<GT>::
set_size (int w, int h)
{
	// TODO
}

template<typename GT>
template<typename PointIter>
void
TanSet<GT>::
add_obstacle (PointIter begin, PointIter end)
{
	// TODO
}

template<typename GT>
void
TanSet<GT>::
pan (const vector &)
{
	// TODO
}

template<typename GT>
const typename TanSet<GT>::container &
TanSet<GT>::
tans () const
{
	return _tans;
}

template<typename GT>
const typename TanSet<GT>::tan &
TanSet<GT>::
selection () const
{
	// TODO
}

template<typename GT>
const typename TanSet<GT>::tan *
TanSet<GT>::
find (const point & p) const
{
	for (typename container::iterator i = _tans.begin(); i != _tans.end(); i++)
		if (i->contains(p))
			return &(* i);

	return NULL;
}

template<typename GT>
typename TanSet<GT>::tan *
TanSet<GT>::
find (const point & p)
{
	// TODO: duplication
	for (typename container::iterator i = _tans.begin(); i != _tans.end (); i++)
		if (i->contains(p))
			return &(* i);

	return NULL;
}

/*
** vim: syntax=cpp ts=4 sw=4 cindent
*/
