#include <GL/gl.h>
#include <sys/time.h>
#include <iterator>
#include <sstream>
#include <cassert>
#include <iostream>
#include <functional>
#include "resources.h"

static void printInfoLog(GLhandleARB obj)
{
	int infologLength = 0;
	int charsWritten  = 0;
	char *infoLog;

	glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
							  &infologLength);

	if (infologLength > 0)
	{
		infoLog = new char[infologLength];
		glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);
		std::cout << infoLog << std::endl;
		delete infoLog;
	}
}

template<typename GameTraits>
struct BasicRenderer<GameTraits>::WaveState
{
	float x, y, xv, yv;
	GLint handle;

	void update(float dt)
	{
		x += xv * dt;
		y += yv * dt;

		if (x < -3 || x > 3)
			xv = - xv;
		if (y < -3 || y > 3)
			yv = -yv;

		glUniform2fARB(handle, x, y);
	}
};

template<typename GameTraits>
BasicRenderer<GameTraits>::
BasicRenderer (const state & s)
	: _state (s), _waves()
{
}

template<typename GameTraits>
void
BasicRenderer<GameTraits>::
init ()
{
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_BLEND);

	glPointSize(10.0);

	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	// shader setup

	glewInit();
	assert(GLEW_ARB_vertex_shader && GLEW_ARB_fragment_shader);

	GLhandleARB fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

	std::string fragShaderSource = resource_read("shader.frag");
	const GLcharARB * c = fragShaderSource.c_str();
	glShaderSourceARB(fragShader, 1, &c, NULL);
	glCompileShaderARB(fragShader);
	printInfoLog(fragShader);

	_shader = glCreateProgramObjectARB();
	glAttachObjectARB(_shader, fragShader);
	glLinkProgramARB(_shader);
	printInfoLog(_shader);
	glUseProgramObjectARB(_shader);

	for (int i = 0; i < 3; i++)
	{
		std::ostringstream name;
		name << "waves[" << i << "]" << std::ends;

		WaveState wave;
		wave.handle = glGetUniformLocationARB(_shader, name.str().c_str());
		wave.x  = (float) rand() / RAND_MAX * 6.0 - 3.0;
		wave.y  = (float) rand() / RAND_MAX * 6.0 - 3.0;
		wave.xv = (float) rand() / RAND_MAX * 0.3 - .15;
		wave.yv = (float) rand() / RAND_MAX * 0.3 - .15;

		_waves.push_back(wave);
	}

	glUniform1iARB(glGetUniformLocationARB(_shader, "nwaves"), _waves.size());
}

template<typename GameTraits>
void
BasicRenderer<GameTraits>::
reshape (int w, int h)
{
	_width = w; _height = h;

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	double waspect = float (w) / float (h);
	double haspect = float (h) / float (w);

	if (waspect < 1.0)
		waspect = 1.0;
	else
		haspect = 1.0;

	gluOrtho2D(-4.0 * waspect, 4.0 * waspect, 4.0 * haspect, -4.0 * haspect);
	glViewport(0, 0, w, h);
}

template<typename GameTraits>
typename GameTraits::point
BasicRenderer<GameTraits>::
transform (int x, int y) const
{
	point result (x, y);
	point origin (_width / 2, _height / 2);

	result -= origin;

	int size = _width < _height ? _width : _height;

	result /= size;
	result *= 8;

	return result;
}

static float get_elapsed()
{
	static timeval last;
	static bool   first = true;

	if (first)
		gettimeofday(&last, NULL);

	timeval now;
	gettimeofday(&now, NULL);

	float result = (now.tv_sec - last.tv_sec) * 1e3 + (now.tv_usec - last.tv_usec) * 1e-3;

	last = now;
	return result;
}

template<typename GameTraits>
void
BasicRenderer<GameTraits>::
render ()
{
	glClear(GL_COLOR_BUFFER_BIT);

	typedef typename GameTraits::tanset tanset;

	const tanset & tans = _state.tans();

	glUseProgramObjectARB(_shader);
	std::for_each(_waves.begin(), _waves.end(), std::bind2nd(std::mem_fun_ref(&WaveState::update), get_elapsed()));

	for (typename tanset::container::const_iterator i = tans.begin(); i != tans.end(); i++)
	{
		typedef typename std::vector<typename GameTraits::point> pointset;

		pointset points;
		i->points(std::back_inserter(points));

		if (i == _state.selection())
			glColor4f(0.2, 0.0, 1.0, 1.0);
		else
			glColor4f(0.13, 0.0, 0.66, 1.0);

		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

		glUseProgramObjectARB(_shader);

		glBegin(GL_POLYGON);

		for (typename pointset::reverse_iterator j = points.rbegin(); j != points.rend(); j++)
		{
			glTexCoord2f(j->real(), j->imag());
			glVertex2f(j->real(), j->imag());
		}

		glEnd();

		glColor4f(0.06, 0.0, 0.32, 1.0);
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glLineWidth(2.0);
		glUseProgramObjectARB(0);
		glBegin(GL_POLYGON);

		for (typename pointset::reverse_iterator j = points.rbegin(); j != points.rend(); j++)
		{
			glVertex2f(j->real(), j->imag());
		}

		glEnd();
	}

	/*
	typedef typename tanset::obstacles::arrangement arrangement;
	typedef typename arrangement::Vertex_const_iterator iter;

	const arrangement & arr = tans.get_obstacles().get_impl();

	glBegin(GL_POINTS);
	for (iter i = arr.vertices_begin(); i != arr.vertices_end(); i++)
		glVertex2f(i->point().x(), i->point().y());
	glEnd();
	*/
}

/*
** vim: ts=4 sw=4 cindent syntax=cpp
*/

